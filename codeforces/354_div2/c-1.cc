//아, 이 binary search는 바꾸기 시도가 가능한 k만큼의 기회를 가지고
//최대 길이 mid(m = (l+r)/2)가 답이 될 수 있는지를 보는 것이다.
//만약 mid만큼의 길이가 답인지 확인해 봤는데 답이 될 수 있다면,
//더 큰 mid값을 적용해서 더 큰 길이가 답이 될 수 있는지를 확인한다.
//
//이제 푸는 방법은 알았는데 d[]배열에 주목해야 한다.
//d[]배열은 (i,j]구간을 모두 b로 통일하기 위해 바꿔야하는 a의 개수를 의미한다.
//그럼 왜 a를 통일하기 위해 바꿔야하는 b의 개수는 따로 구하지 않는 것인가?
//그 부분은 아래의 코드에서 if(v<=k || m-v<=k) 부분이 해결해 주고 있다.
//v값은 (i,j]구간에서 d[j]-d[i]값을 의미한다. 즉, (i,j]구간에서 바꿔야하는 a의 개수를 의미한다.
//그럼 (i,j]구간에서 바꿔야 하는 b의 개수는 어떻게 될까?
//m-v가 된다.
//
//여기서 부터 헷갈리기 시작한다. 그럼 헷갈리는 요인을 짚어보자. 왜 m-v란 말인가?
//m은 l과 r의 중간으로.. 인덱스잖아??? (아냐 멍청아)
//m이 l과 r의 중간인데, 이게 인덱스를 의미하는게 아니라 길이를 의미하는 것에 주의해야 한다.
//그러니까 내가 m이라는거를 하나 택해서 정답에 적용해 보는 것이다.
//이때 m이 의미하는건 가운데 인덱스가 아니라 길이를 의미하는 것이다.
//그럼 v값이 (i,j]에서 모두 b로 통일하려면 바꿔야 하는 a의 개수를 의미하는 것이고,
//이때 (i,j]의 길이는 항상 m이므로 해당 구간에서 문자열 모두를 a로 통일하려면 바꿔야 하는 b의 개수는
//m-v가 될 수 밖에 없다. 그럼 m-v값도 k보다 작거나 같은 경우를 고려해주면 된다.
//
//한가지 더 헷갈렸던 점을 쓰자면,
//어떻게 v<=k와 m-v<=k를 같이 고려할 수 있냐는 것이었다.
//나는 처음에 v<=k따로 m-v<=k부분 따로 나눠서 bs를 작성해야 한다고 생각했다.
//하지만... 당근 아니지 멍청아!!!!!!!!
//그니까.. m길이 만큼을 a를 바꾸던 b를 바꾸던 하나로 통일하는거야
//문쟈열은 (0,n]구간에 있으니까 m길이를 해당 구간에서 다 해보는거지...
//아무튼 여기서 a를 바꾸던 b를 바꾸던 m길이 만큼이 답으로 가능하다면,
//m값을 늘려서 다시 해보는 거는 아무 문제가 없잖아?
//그게 if(v<=k || m-v>=k) 부분임 ㅎㅎ
//이제 끝.! 진짜 완벽하게 이해했다~
#include <stdio.h>
char s[100001];
int d[100001];
int main() {
    int n, k;
    //freopen("/Users/lian/allCode/codeforces/354_div2/input.txt","r",stdin);
    scanf("%d%d",&n,&k);
    scanf("%s", s);
    for(int i=0; i<n; i++) {
        d[i+1] = d[i] + (s[i]=='a');
    }
    int l=0, r=n;
    while(l<r) {
        int m=(l+r+1)/2;
        //printf("%d %d %d\n",l,m,r);
        bool good = false;
        for(int i=m; i<=n; i++) {
            int v = d[i] - d[i-m];
            if(v<=k || m-v<=k) {
                good = true;
                break;
            }
        }
        if(good) l=m;
        else r = m-1;
    }
    printf("%d", l);
    //fclose(stdin);
    return 0;
}
