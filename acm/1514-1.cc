//이 문제에서는 오른쪽이나 왼쪽으로 최대 3번만큼 변경횟수 1을 사용하여 돌릴 수 있다고 한다.
//그런데 이를 왼쪽으로 몇번돌리고 오른쪽으로 몇번 돌리는지를 계속 고려하면 뇌가 꼬이기 시작한다.
//결국 이 문제를 푸는 방법은 어느방향으로 몇번 돌렸느냐를 생각하는 것이 아니라,
//자물쇠의 현재 번호가 [0,4,1,4]이고 이를 푸는 번호가 [2,4,5,6]이라면
//[0,4,1,4]상태에서 [2,4,5,6]의 상태로 도달하는 '최소 변경횟수'는 몇일까?라는 관점으로 문제를 접근해야 한다.
//물론 이렇게 하면 상태가 2^100개나 되므로 조금 더 생각을 해봐야한다.
//
//이 문제의 2번째 조건을 보면, 연속한 디스크를 3개까지 돌릴 수 있다고 되어있다.
//즉, 디스크의 상태값은 하나 또는 연속된 2~3묶음 단위로 움직인다는 뜻이다.
//그럼 자물쇠의 디스크 하나하나를 상태로 표현하는 dp식은 필요 없음을 깨달을 수 있다.
//즉, 한번에 연속된 3개의 디스크 상태만 보면 되는 것이다. (그럼 1개의 디스크만 돌렸을때와 연속된 2개의 디스크만 돌렸을때의 상태를 모두 포함할 수 있다.)
//그리고 여기서 조금 더 생각해보면 x번째 디스크를 기준으로 first, second, third disk를 어떻게 돌렸는지 모두 상태로 기록할 필요가 없음을 알 수 있다.
//왜냐하면 first disk를 자물쇠 정답 번호쪽으로 돌리는데 드는 비용을 바로 계산할 수 있기 때문이다.
//그러면 연속된 디스크 2개의 상태만으로 해결이 가능하다.
//
//그럼 몇번째 disk를 기준으로 보냐에 따라 2가지 상태만 보면 되는 것이므로
//상태공간은 dp[100][10][10]으로 잡을 수 있다.
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int inf = 0x3f3f3f3f;
// cost[k]는 현재 디스크를 오른쪽으로 k번 만큼 돌린 상태를 얻는데 필요한 변경횟수이다.
// 이는 디스크를 왼쪽으로 k번 만큼 돌린 상태를 얻는데 필요한 변경횟수와도 같다. (대칭을 이루고 있음.)
int cost[] = {0,1,1,1,2,2,2,1,1,1};
int d[101][10][10], disk[100], dest[100];
int ABS(int x) { return x<0?-x:x; }
int main() {
    int n;
    scanf("%d",&n);
    for(int i=0; i<n; i++) scanf("%1d", &disk[i]);
    for(int i=0; i<n; i++) scanf("%1d", &dest[i]);
    memset(d, 0x3f, sizeof(d));
    d[0][0][0] = 0;
    int ans = inf, tc;
    for(int x=0; x<n; x++) {
        //d[x][i][j]: disk[x]의 초기 상태에서 i만큼 오른쪽으로 돌아갔고, disk[x+1]도 최초의 상태에서 j만큼 오른쪽으로 돌아갔을 때,
        //초기 자물쇠 상태에서 얼만큼 돌아간 것인지 저장되어있다.
        for(int i=0; i<10; i++) {
            for(int j=0; j<10; j++) {

                //현재 상태를 d[x][i][j]라 하자. 이 값이 inf가 아니라면 초기상태 0,0,0에서 어떻게든 돌려서 x,i,j 상태까지 왔다는 것임.
                //그리고 여기엔 현재까지의 자물쇠를 변경한 최소 횟수가 들어가 있음.
                int &cur = d[x][i][j];
                if(cur == inf) continue;

                //이제 현재 자물쇠 상태에서 x번째 디스크를 기준으로 디스크 2개를 통째로 u만큼, 디스크 3개를 통째로 v만큼 돌려보자.
                //이 모든 경우를 다 돌려보면서 next(다음 상태값)를 업뎃하자!
                for(int u=0; u<10; u++) { //x번째 디스크를 기준으로 연속된 디스크 2개를 돌리는 횟수
                    for(int v=0; v<10; v++) { //x번째 디스크를 기준으로 연속된 디스크 3개를 돌리는 횟수

                        //cost[( (disk[x]+(i+u+v)) - dest[x] + 10)%10]에서
                        //disk[x]+(i+u+v)는 x번째 디스크를 오른쪽으로 i+u+v만큼 돌렸을 때를 의미한다. (이를 curState라 언급하겠음.)
                        //(어차피 이따가 10으로 mod연산을 해야  하므로 미리 나머지를 계산하지 않는다.)
                        //이제 curState에서 x번째 디스크가 최종적으로 도달해야하는 번호까지 돌리는데는
                        //cost[( (curState - dest[x] + 10)%10]만큼의 비용이 든다.
                        //이제 전체 비용 tc는 아래의 식과 같음을 알 수 있다.
                        tc = cur + cost[u] + cost[v] + cost[( (disk[x]+(i+u+v)) - dest[x] + 10)%10];
                        //업뎃이 되는 다음 상태는 x+1번째 disk를 disk[x+1]의 초기상태에서 j+u+v만큼 오른쪽으로 돌리고 x+2번째 disk를 v만큼 오른쪽으로 돌린 상태이다.
                        int &next = d[x+1][(j+u+v)%10][v];
                        if(next > tc) {
                            next = tc;
                            if(x==n-1) ans = min(ans, next);
                        }
                    }
                }

            }
        }
    }
    printf("%d\n", ans);
    return 0;
}
