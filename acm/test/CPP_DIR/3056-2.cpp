//만약 n이 20이라고 하면,
//n이 19일때 f(19,s)가 의미하는 바는
//19번째 지미 본드가 임무를 수행했을때의 성공할 최대확률이 들어있는 것이다.
//그럼 20번째 지미 본드가 임무를 수행했을떄의 성공할 최대확률은
//19번째 지미 본드가 임무를 수행했을때의 성공할 최대확률(f(19,s)) * 아직 상태에서 체크하지 않은 하나 (v[20][s에 체크되지 않은놈]) 이다.
//즉, d[20][s'] = f(20,s') = f(19,s)*v[20][s에서 체크되지 않은놈] 인 셈이다.
//그런데 d[20][s']을 d[s']만으로 나타낼 수 있다.
//왜냐하면 d[x][s']은 항상 d[x-1][s]만 고려하기 때문이다. 즉, 이전 dp값만 고려하기 때문에
//이를 1차원 dp형태로 표현하는 것이 가능하다.
//그럼 d[s]는 계속 업뎃되는게 아니냐??? 계속 업뎃 되면 아래와 같은 dp식을 세울 수 없을텐데 말이다.
//흠... 아니다! (d[s]를 리턴하기 전까지는 계속 큰 값으로 업뎃이 되지만, 일단 리턴이 되고 나면 그것은 정말 유일한 값이 된다.)

//이 방식은 생각을 bottom-up 처럼 적었지만, top-down이잖아
//그러니까 내가 20번째 지미 본드가 20개의 임무중 하나를 선택하게 한 다음에
//19번째 지미 본드에게 다음 선택할 임무를 고르게 하는 방식이다.
//그럼 20번째 지미 본드가 20개의 임무를 모두 선택해보게 한다면,
//각각의 경우마다 해당임무를 뺀 나머지 19개의 임무 선택지를 19번째 지미본드에게 물어보게 되는 것이고,
//이 중에 최대값만 d[s]에 저장되는 것이다. 참고로 s는 1<<20까지만큼 있다. 20이라고 착각하지 말자.

//즉, 모든 d[s]에는 x번째 지미 본드까지 임무를 수행할때,
//0~x번째 지미 본드가 1,2,3,8,9번 임무를 수행한다면 (누가 어떤 임무를 수행하는지는 모름)
//이게 모두 동일한 상태로 기록이 되는 것이고(0번째 지미 본드가 1번 임무를 수행하고 1번쨰 지미본드가 2번임무를 수행하는 것과, 0번째 지미본드가 2번 임무를 수행하고 1번째 지미본드가 1번 임무를 수행하는 것을 같은 상태로 나타낸다는 의미)
//해당 상태중 d[s]에는 최대값만 기록된다. 그리고 해당 최대값이 전부 기록되기 전까지는 리턴을 하지 않으므로
//이 dp식은 1차원만으로 기술하는것이 가능하다.
#include <stdio.h>
int n;
double v[20][20], d[1<<20], tmp;
double f(int x, int s) {
    if(x<0) return 1;
    if(d[s]>0) return d[s];
    for(int i=0; i<n; i++) {
        if(s&(1<<i)) { //(1<<i) 상태가 s에 들어있으면 true
            tmp = v[x][i] * f(x-1, s^(1<<i)); //(1<<i)상태를 s에서 빼준다.
            if(d[s] < tmp) d[s]=tmp;
        }
    }
    return d[s];
}
int main() {
    scanf("%d", &n);
    for(int i=0; i<n; i++) {
        for(int j=0; j<n; j++) {
            scanf("%lf", &v[i][j]);
            v[i][j]/=100;
        }
    }
    printf("%.6lf", f(n-1,(1<<n)-1)*100);
    return 0;
}
